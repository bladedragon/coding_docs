# 计算机组成原理





# 链接、装载与库

## 计算机基础

### 操作系统

操作系统的一个功能是提供抽象的接口，另外一个主要功能是管理硬件
资源。

一个计算机中的资源主要分CPU、存储器（包括内存和磁盘）和I/O设
备

**历史**

+ 监控程序监控
+ 协作式分时系统
+ 多任务抢占式

### 硬件驱动

驱动程序可以看作是操作系统的一部分，它往往跟操作系统内核一起运行在特权级级，但它又与操作系统内核之间有一定的独立性，使得驱动程序有比较好的灵活性。

磁盘驱动程序向硬件发送IO命令的方式常见的有通过读写IO端口寄存器的方式实现

### 内存分配

存在问题

+ 内存使用效率低
+ 程序运行地址不确定
+ 地址空间不隔离

解决方法: 增加中间层，采用间接地址访问的方式 

+ 分段
+ 分页



### 线程简介

线程的组成

+ 线程ID
+ 当前指令指针（PC）
+ 寄存器集合
+ 堆栈

![image-20200920100705061](documents/计算机组成原理/image-20200920100705061.png)



#### **线程调度和优先级**

线程调度的方法基于轮转法和优先级法，现代几乎所有的调度方法都带有这两种方法的痕迹

+ 频繁等待的线程叫做IO密集型线程

+ 很少等待的线程称之为CPU密集型线程
+ IO密集型线程总是比CPU密集型线程容易得到优先级的提
  升。

线程优先级改变的三种方式

1. 用户指定优先级
2. 根据等待时间的频繁程度提升或降低优先级
3. 长时间得不到执行而被提升优先级

#### **可抢占线程和不可抢占线程**

不可抢占线程的特点是线程调度的时机是**固定**的，线程调度只会发生在线程主动放弃执行或者线程等待某事件的时候。



#### **Linux的多线程**

Linux将所有的执行实体（无论是线程还是进程）都称为任务（Task），每一个任务概念上都类似于一个单线程的进程，**具有内存空间**、**执行实体**、**文件资源等**。不过，Linux下不同的任务之间可以选择共享内存空间

| 系统调用 | 作用                                             |
| -------- | ------------------------------------------------ |
| fork     | 复制当前线程， 一开始只是共享内存空间，写时复制  |
| exec     | 使用新的可执行映像覆盖当前可执行映像，执行新任务 |
| clone    | 创建子进程并从指定位置开始执行                   |



##### 同步和锁

+ 二元信号量

  它适合只能被唯一一个线程独占访问的资源。只有占用和非占用两种状态

+ 多元信号量，也就是常说的信号量

+ 互斥锁

  同一个信号量可以被系统中的一个线程获取之后由另一个线程释放；而互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁

+ 临界区

  互斥量和信号量在系统的任何进程里都是可见的；临界区的作用范围仅限于本进程，其他的进程无法获取该锁

+ 读写锁

+ 条件变量：使用条件变量可以让许多线程一起等待某个事件的发生，类似于栅栏



**可重入：**表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行

+ 多个线程同时执行这个函数
+ 函数自身调用自身



**过度保护：**加锁之后依然可能会出现指令重排序或者寄存器缓存变量（缓存之后下次操作就可以直接从寄存器中读取而不是要重新访问内存）的行为

+ java中的volatile带有内存屏障的作用，所以不仅可以确保变量的可见性也可以防止指令的重排序

+ 但是c中的volatile只能保证变量的可见性，即使可以阻止编译器的重排序也不能阻止CPU的动态顺序调度
+ 在C中必须使用barrier实现内存屏障

```C
#define barrier()  __asm__ volatile (”lwsync”)
```



##### 线程模型

1. 一对一线程模型

   优点：线程之间的并发是真正的并发

   缺点：上下文切换开销大，执行效率低；线程数量收到限制

2. 多对一线程模型：将多个用户线程映射到一个内核线程上，线程之间的切换由
   用户态的代码来进行

   缺点：一个用户线程阻塞导致整个内核线程阻塞

   优点：高效的上下文切换和几乎无限制的线程数量

3. 多对多线程模型：将多个用户线程映射到少数但不止一个内核线程上

   优点：在多处理器上线程也能得到一定程度的性能提高



## 静态链接

linux编译过程

+ **预处理**

+ **编译**

  扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化

+ **汇编**

+ **链接**

  主要是链接外部模块

### 编译器

词法分析

语法分析

语义分析

中间语言生成

目标代码生成和优化



### 链接器

链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。

> 在编译之后才链接可以防止每次源文件修改后都要重新修正引入文件的地址（重定位）

**连接过程**

1. 地址和空间分配
2. 符号决议
3. 重定位



## 目标文件

> 编译器编译源代码后生成的文件叫做目标文件





### ELF文件结构

![image-20200925162841394](documents/计算机组成原理/image-20200925162841394.png)



# 

#### 字符串表

是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串，只有i知道段表和段表字符串表的位置才能解析整个Elf文件



## 链接的接口：符号

> 在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。



符号表的类型

+ 定义在本目标文件的全局符号：可以被其他目标文件引用
+ 段名：这种符号由编译器生成，值就是该段的起始地址
+ 局部符号：只在编译单元可见，用来分析转储文件，对链接阶段没有用处
+ 行号信息：目标文件指令与源代码中代码行的对应关系



### 符号表结构



### 特殊符号

> 这些符号并没有在你的程序中定义，但是你可以直接声明并且引用它

这些特殊符号可以直接在C代码中使用



### 符号修饰和函数签名

`unix`下 C语言编译后变量名前面会加下划线`_`;Fortran语言会在变量名前后加下划线`_`(现在这些配置都是可以更改的)

**C++的符号修饰**

+ C++中使用了函数签名：函数签名包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息
+ 函数签名会在编译成目标文件之后被修饰 成符号名 
+ 不同编译器厂商指定的符号修饰名规则不同，因此不同编译器之间不能互操作
+ 使用C++的宏 “`__cplusplus`”，C++编译器会在编译C++的程序时默认定义这个宏，我们可以使用条件宏来判断当前编译单元是不是C++代码。



### 弱符号和强符号

对于C/C++语言来说，编译器默认**函数和初始化了的全局变量**为强符号，**未初始化的全局变量**为弱符号

可以通过GCC的 “`__attribute__((weak))`” 来定义任何一个强符号为弱符号

链接器就会按如下规则处理与选择被多次定义的全局符号:

1. 规则1：不允许强符号被多次定义（即不同的目标文件中不能有同名的强符号）；如果有多个强符号定义，则链接器报符号重复定义错误。
2. 规则2：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。
3. 规则3：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。比



### 强引用和弱引用

+ 对于符号引用，如果没有找到符号定义，链接器会报错，这种引用是强引用 

+ 如果有定义，链接器就将该符号的引用决议，如果没有定义，不报错，而是拿一个初始值初始化它，这种引用是弱引用, 弱引用可以被强引用覆盖

在GCC中，我们可以通过使用 “`__attribute__((weakref))`” 这个扩展关键字来声明对一个外部函数的引用为弱引用



调试信息





## 四、静态链接

>“链接器为目标文件分配地址和空间”这句话中的“地址和空间”其实有两个含义：第一个是在输出的可执行文件中的空间；第二个是在装载后的虚拟地址中的虚拟地址空间。
>
>+ 像bss虽然在输出的可执行文件中不占文件的空间，但是在装载的时候还是占了一定的地址空间

现在的链接器空间分配的策略基本上都采用了**两步链接**

1. 空间与地址分配：收集所有符号定义和符号引用统一放到全局符号表，确定链接后文件中符号在段中的偏移
2. 符号解析和重定位：存有重定位表（存引用到外部符号的地址）和全局符号表（重定位过程也伴随着符号的解析过程）
   + 链接的时候需要进行指令修正



### COMMON块

+ 当不同的目标文件需要的COMMON块空间大小不一致时，以最大的那块为准。、

+ 直接导致需要COMMON机制的原因是编译器和链接器允许不同类型的弱符号存在，但最本质的原因还是链接器不支持符号类型，即链接器无法判断各个符号的类型是否一致。





### BFD

> BFD库将目标文件抽象成一个统一的模型
>
> 使得BFD库的程序只要通过操作这个抽象的目标文件模型就可以实现操作所有BFD支持的目标文件格式。



## windows PE/COFF

PE指的是Windows的可执行格式，一开始是COFF

PE可执行文件又被称之为image file

> 因为PE文件在装载时被直接映射到进程的虚拟空间中运行，它是进程的虚拟空间的映像



> VS使用visual C++作为编译器（MSVC）
>
> 除此之外还有Mingw（用的GCC），Clang（基于LLVM的编译器，性能出色，比较高级）







### 九、Windows下的动态链接

+ DLL文件的扩展名不一定是.dll，也有可能是别的比如`.ocx`（OCX控件）或是``.CPL`（控制面板程序）。
+ PE文件实现进程间通信一种的方法：使用DLL文件的共享数据段，但这种方法也容易遭到入侵
+ 







# 深入理解计算机系统

**系统硬件组成**

+ 总线

  携带信息字节传递信息

+ IO设备

  通过控制器或适配器和IO总线相连。

+ 主存

+ 处理器（CPU）       



**缓存**

![image-20201007164032249](documents/计算机组成原理/image-20201007164032249.png)



### 操作系统管理硬件

**操作系统的两个基本功能**：

1. 防止硬件被失控的应用滥用
2. 向应用程度提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备

![image-20201007164851346](documents/计算机组成原理/image-20201007164851346.png)

文件：就是字节序列，**为应用程序提供了统一的视图**



## 信息的表示和处理

### 信息存储

指针：提供了引用数据结构的机制

**字数据大小：**

字长：指明指针数据的标称大小。字长决定的最重要系统参数就是虚拟地址空间最大大小。

**寻址和字节顺序：**

排列顺序：小端法和大端法（甚至还有双端法），区别是有效字节的摆放是前是后。



**文本数据比二进制数据具有更强的平台独立性**



**移位操作**

+ 左移：右侧填充0
+ 右移：存在逻辑右移和算术右移，算术右移主要用在计算负值的时候
+ 移动数量大于总数，结果是未定义的，一般计算机都是按照mod处理
+ 算术右移：最高位填充符号位。正数填充0，负数填充1
  逻辑右移：最高位填充0

### 整数表示

对于unsigned来说，二进制转十进制只是一种转换

对于signed来说，第一位代表符号位，后面才是转换

![image-20201012093925275](documents/计算机组成原理/image-20201012093925275.png)

补码存在的意义：



**扩展一个数的位表示**：零扩展

比如需要将一个数从16位扩展到32位，如果是负数就填充1如果是正数就填充0

**截断数字：**截断后的数字相当于原数字mod  2的k（截断后的位数）次

![image-20201012162802357](documents/计算机组成原理/image-20201012162802357.png)

![image-20201012163548008](documents/计算机组成原理/image-20201012163548008.png)

如原数字为(int) 53191，截断后的数字为(short) 53191 - 65536（2mod16） = -12345

> java >>表示算术右移（带符号） >>>表示逻辑右移

### 整数运算





### 浮点数

第一种浮点数表示法存在局限性

1. 只能表示形如`x/2^k`的有理数
2. 浮点限制了数字的范围，如果浮点左移，得到了更小的数字范围但是更精确的小数，如果浮点右移，得到了更大的数字范围但是更差的精度



**IEEE浮点数**

> IEEE统一了浮点数的标准

![image-20201112172111519](documents/计算机组成原理/image-20201112172111519.png)

+ 符号位s确定了该数字是正数还是负数
+ 尾数M是一个介于1和2的小数
+ 指数E会以2的E次幂形式扩大或缩小尾数值



![image-20201112172349998](documents/计算机组成原理/image-20201112172349998.png)

+ `exp`编码了`E`，但是和`E`不同，同理`frac`编码了`M`
+ 因特尔还有一种非标准的编码方式



+ E = Exp-Bias，Bias  = 2的(k-1)次方-1

+ M = 1.xxx...x
+ 通过E控制浮点的左移右移

![image-20201113170630479](documents/计算机组成原理/image-20201113170630479.png)



非规格化值

![image-20201113171935077](documents/计算机组成原理/image-20201113171935077.png)

用于需要表示一个靠近0的数值的时候，使用非规格化值可以使得数值不受隐含的1的限制





![image-20201116102043915](documents/计算机组成原理/image-20201116102043915.png)

非标准化和标准化设计的意义，实现浮点数的平滑过渡



为什么Bias使用2的(k-1)-1?

+ 因为需要给出一个最小指数和最大指数中间的值
+ Exp的取值目前是固定的0000到1111，我们想要这个Exp区域既能表示正幂又能表示负幂而且正负幂之间尽量对称，所以Bias就是一个移位的偏移量





**浮点数乘法**

![image-20201116104259811](documents/计算机组成原理/image-20201116104259811.png)

+ 注意出现的特殊情况



**浮点数加法**

![image-20201116110338438](documents/计算机组成原理/image-20201116110338438.png)

+ 当大数加小数的时候因为没有足够的位来表示小数，小数就会被舍入





## 程序的机器级表示

编译器相当聪明，在编译switch语句的时候，是通过一个索引数组的方式索引到指定的代码块中，如果case中出现负数，编译器会添加一个偏置（bias）使得最小的索引大于等于0，如果出现少量case但是中间间隔大量数字就会转化成if-else语句



处理器用流水线方式获得高性能，通过提前缓存下一条指令序列来实现。如果遇到分支就会使用分支预测技术



### 过程

程序使用栈来管理过程调用和返回的状态，在栈中，程序传递潜在信息，控制信息和数据，并分配本地数据

栈存在两个指针，`%rsp`和`%rbp`(可选的)，其中`%rbp`存在于变长栈帧中，用于无法预知分配数组大小的时候



![image-20210113144304637](documents/计算机组成原理/image-20210113144304637.png)



##### ![image-20210113144322049](documents/计算机组成原理/image-20210113144322049.png)







## 优化程序性能

限制程序的最大性能的两种情况

+ 延迟界限：当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能
+ 吞吐量界限：刻画了处理器功能单元的原始计算能力，这个界限是程序性能的终极限制



![image-20210202220824702](documents/计算机组成原理/image-20210202220824702.png)

分支预测技术

投机执行技术





## 存储器层次结构

### 存储技术

RAM（随机访问存储器）

+ 静态RAM（SRAM）
+ 动态RAM（DRAM）
+ 增强型DRAM
  + FPM DRAM
  + EDO DRAM
  + SDRAM
  + DDR DRAM
  + VRAM

ROM（非易失性存储器）

+ PROM
+ EPROM
+ 闪存

访问主存

+ IO桥接器

+ 系统总线
+ 内存总线

![image-20210205162757092](documents/计算机组成原理/image-20210205162757092.png)



#### 磁盘存储

![image-20210205170333528](documents/计算机组成原理/image-20210205170333528.png)



扇区访问时间

+ 寻道时间
+ 旋转时间

![image-20210205173746500](documents/计算机组成原理/image-20210205173746500.png)

+ 传送时间

![image-20210205173756463](documents/计算机组成原理/image-20210205173756463.png)





### 局部性原理

+ 空间局部性
+ 时间局部性



### 高度缓存存储器

组选择-> 行匹配 -> 字选择

+ 直接映射高速缓存

+ 组相联高速缓存
+ 全相联高速缓存



写入的问题

+ 直写（写命中）
+ 写分配（写不命中）
+ 非写分配（写不命中）



高速缓存参数的性能影响

+ 高速缓存的大小
+ 块大小
+ 相联度
+ 写策略



### 堆

malloc实现：因为系统调用开销大，最好是用户空间申请一块，然后自己管理。管理内存空间分配的一般是运行库

堆分配算法

+ 空闲链表
+ 位图



